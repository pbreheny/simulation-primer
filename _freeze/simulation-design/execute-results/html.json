{
  "hash": "253edab5212ba79296b278edecbe9d90",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: A Primer on Simulation Design\nauthor: Patrick Breheny\ndate: today\nhtml-math-method: katex\ncode-annotations: hover\nformat:\n  html:\n    html-table-processing: none\n    self-contained: true\n    toc: true\n---\n\n\n\n\n\nThis is an introduction to how to write and organize a simulation study. It is intended for students who have limited experience carrying out such studies before. However, it may also prove valuable to students who have carried out many simulation studies, but struggle to organize them well. The focus here is almost entirely on the organization. The *science* of designing a good simulation study is obviously also very important, but is a large topic; some links where you can read further about this are given at the end.\n\nTo download the source code so that you can run (and modify) this simulation yourself, visit the [GitHub repsoitory](https://github.com/pbreheny/simulation-primer).\n\n# Principles\n\nThere are three important principles to keep in mind as you write simulation code:\n\n1. The results should be tidy and complete\n2. The code that implements the simulation should be simple, modular, and readable\n3. The code that runs the simulation should be separate from the code that presents the simulation results\n\nWe will now discuss these principles in detail, then describe the general structure of a simulation study.\n\n## Tidy and complete\n\nAs with many programming tasks, it helps to start at the end: what should the finished product look like?\n\nThere is a strong argument to be made that the results should be \"tidy\", meaning organized into a simple data frame of rows and columns. More complicated structures are certainly possible (lists, arrays, etc.); indeed, I used to store results in these formats. However, experience has taught me that a simple data frame is best, for several reasons:\n\n1. It is by far the most common way of storing data, so it will never be unfamiliar to you (unlike, say, a complex hierarchical list).\n2. Data frames are easy to merge and combine.\n3. Committing to a hierarchical structure makes it hard to modify the simulation; if you change the parameters, will the entire structure change? This is not desirable.\n4. Because they are so common, many powerful tools work well with data frames, such as the data manipulation packages **data.table** and **dplyr** and the graphics package **ggplot2**. You will likely want to get your simulation results into a data frame eventually anyway in order to summarize and plot them, so why not just store them like this in the first place?\n\nSecond, by \"complete\", I mean that you should try to record the relevant information that went into the simulation as part of the object: things like sample sizes, standard deviation of error terms, things that would be passed as arguments to functions (see [structure](#structure) later). It's impractical to be truly complete (storing all the packages you loaded, their version numbers, the git hash of your codebase, etc.; it's not bad to store these things, but typically this is overkill), but in general, when in doubt, go ahead and store this information as columns in your data frame. Storage is cheap and you'll never regret having too much information about your simulation (especially if you're working in collaboration with someone else or coming back to a project in the future).\n\n## Simple, modular, and readable\n\nThe script that runs the simulation should be short and readable. In particular, complicated details involved in implement a method or generating data should be implemented as functions and placed in separate files. It's much harder to read a simulation script and grasp the flow and big picture if it also contains hundreds of lines of code implementing details. Keep those details elsewhere.\n\nIn particular, all of these details should be functions that can accept arguments -- this keeps your simulation *modular*, which is extremely important. You may not appreciate this if you haven't done research yet, but one typically has to try out dozens of simulation settings before finding the most interesting set up.\n\n## Separation\n\nNot only does one typically explore a number of settings, but the ways of summarizing and presenting a simulation are endless and typically involve a lot of tinkering, especially as you get ready to share or publish your results. It is essential that you separate the code that performs the simulation from the code that does the summarization and plotting. Simulations take a long time -- you don't want to rerun the simulation every time you change the colors or aspect ratio of a plot.\n\n# Structure\n\nAll simulations studies have the same basic structure:\n\n1. **Generate** the data \n2. **Analyze** that data\n3. **Summarize** how well the analysis worked\n\nIn a complex simulation, these steps may be lengthy and complicated. However, by abstracting the details of these steps into functions and passing simulation options as arguments to these functions, we can keep the simulation structure organized, easy to read, and modular.\n\n# Example #1\n\nLet's go through an example. Here, I'll simulate two-group data with different sample sizes, different standard deviations, and potentially different means, then analyze the data using a two-sample $t$-test that assumes equal variances. In my simulation, I'll keep the total sample size at $n$=20, but change how many are in group 1 vs group 2.\n\nIn this particular example, generating the data isn't too complicated. However, I'll write a function for the data generation so that you can see what it looks like to abstract these details away:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(magrittr)\n\ngenerate <- function(n1, n2, sd1, sd2, delta, ...) {\n  x <- rnorm(n1, 0, sd=sd1^2)\n  y <- rnorm(n2, delta, sd=sd2^2)\n  list(x=x, y=y)\n}\n```\n:::\n\n\n\n\n\nNow, here's the code that carries out the simulation. I've made some comments on the code; hover over the little numbers to the right to see the annotations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Evaluate power and type 1 error rate for the t-test when           # <1> \n#' variances are unequal total sample size is always 20               # <1> \n\nsource('functions.r')                                                 # <2>\n\n# Define options                                                      # <3> \nopt <- list(                                                          # <3> \n  rep = 1:1000,                                                       # <3> \n  sd1 = 1,                                                            # <3> \n  sd2 = 1:3,                                                          # <3> \n  n1 = seq(2, 18, 2),                                                 # <3> \n  delta = c(0, 1))                                                    # <3> \n\n# Set up results frame                                                \nres <- expand.grid(opt)                                               # <4> \nres$n2 <- 20 - res$n1                                                 # <5>\nres$p <- NA_real_                                                     # <6> \nres$width <- NA_real_                                                 # <6> \n\n# Loop\npb <- txtProgressBar(0, nrow(res), style=3)                           # <7> \nfor (i in 1:nrow(res)) {                                              # <8> \n  # Generate                                                          # <8> \n  dat <- do.call(generate, res[i,])                                   # <8> \n                                                                      # <8> \n  # Analyze                                                           # <8> \n  out <- t.test(dat$x, dat$y, var.equal = TRUE)                       # <8> \n                                                                      # <8> \n  # Summarize                                                         # <8> \n  res$p[i] <- out$p.value                                             # <8> \n  res$width[i] <-   out$conf.int[2] - out$conf.int[1]                 # <8> \n                                                                      # <8> \n  setTxtProgressBar(pb, i)                                            # <8> \n}                                                                     # <8>\nclose(pb)\n\n# Save\nwrite.csv(res, 'ex-1.csv', row.names = FALSE)                         # <9>\n```\n:::\n\n\n\n1. I strongly recommending adding a short statement at the top of all scripts that describes what the script does.\n2. Details of data generation, etc., go here.\n3. You can combine this step with the next one if you wish, but it is helpful for many reasons to separate the meaningful options -- arguments to the generate, analyze, and summarize function -- from the construction of the data frame to hold the results. Among other things, it lends itself well to use with HPC (see later).\n4. `expand.grid()` is extremely convenient here to set up factorial designs.\n5. Note that this must be done outside `expand.grid()` -- we don't want all combinations of n1 and n2.\n6. These are results; we don't know them ahead of time. Always store these as NA, not 0 or some other number -- in case something goes wrong, you don't want to include analyses that didn't happen as results.\n7. Progress bars are always useful. The base R one is fine, although the one from the **progress** package is a little nicer.\n8. This is the simulation loop. The template is more or less always the same -- generate, analyze, and summarize -- only the details and options change. Note that there are many potential summaries; I've included two, but a more intricate simulation might track dozens of performance metrics.\n9. CSV or TSV files are fine. Parquet files (see the **arrow** package) are even better. The **indexr** package can help with tracking the output.\n\nThe structure of the results is very easy to understand:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres[1:5,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     rep   sd1   sd2    n1 delta    n2         p    width\n   <int> <int> <int> <int> <int> <int>     <num>    <num>\n1:     1     1     1     2     0    18 0.5124239 3.252057\n2:     2     1     1     2     0    18 0.1786291 2.449851\n3:     3     1     1     2     0    18 0.9028190 3.672022\n4:     4     1     1     2     0    18 0.3288347 3.152406\n5:     5     1     1     2     0    18 0.2694675 3.914449\n```\n\n\n:::\n:::\n\n\n\nUsing **data.table**/**dplyr** and **ggplot2**, it's also very easy to summarize and plot the data, even when complex things like subsetting and faceting need to happen:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres[, .(error = mean(p < 0.05)), .(sd2, delta, n1)] %>%\n  .[delta == 0] %>%\n  ggplot(aes(n1, error)) +\n  geom_line() +\n  ylim(0, NA) +\n  facet_grid(~sd2, labeller = 'label_both') +\n  xlab('Sample size (group 1)') +\n  ylab('Type 1 error') +\n  geom_hline(yintercept = 0.05, lty=2, col='gray70')\n```\n\n::: {.cell-output-display}\n![](simulation-design_files/figure-html/unnamed-chunk-6-1.png){width=816}\n:::\n:::\n\n\n\n# Example #2\n\nExample #1 illustrates most of the main ideas. However, most simulations involve a comparison between multiple methods. This introduces a new wrinkle that is worth discussing: the competing methods should analyze the same data. This doesn't necessarily matter in the long run -- with enough replications, differences between random samples will go away -- but it can matter quite a bit in smaller simulations and is worth paying attention to.\n\nImplementing this requires a few small changes to the code; these are annotated below:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Evaluate power and type 1 error rate for the t-test when\n#' variances are unequal total sample size is always 20\n\nsource('functions.r')\n\n# Define options\nopt <- list(\n  equal_var = c(TRUE, FALSE),                                         # <1>\n  rep = 1:1000,                                                       # <1> \n  sd1 = 1,\n  sd2 = 1:3,\n  n1 = seq(2, 18, 2),\n  delta = c(0, 1))\n\n# Set up results frame                                                \nres <- expand.grid(opt)\nres$n2 <- 20 - res$n1\nres$p = NA_real_\nres$width = NA_real_\n\n# Loop\npb <- txtProgressBar(0, nrow(res), style=3)\nfor (i in 1:nrow(res)) {\n  # Generate                                                          # <2> \n  if (i == 1 || res$rep[i] != res$rep[i-1]) {                         # <2> \n    dat <- do.call(generate, res[i,])                                 # <2> \n  }                                                                   # <2>\n                                                                      \n  # Analyze                                                           \n  out <- t.test(dat$x, dat$y, var.equal = res$equal_var[i])           # <3>\n                                                                      \n  # Summarize                                                         \n  res$p[i] <- out$p.value                                             \n  res$width[i] <-   out$conf.int[2] - out$conf.int[1]                 \n                                                                      \n  setTxtProgressBar(pb, i)                                            \n}                                                                     \nclose(pb)\n\n# Save\nwrite.csv(res, 'ex-2.csv', row.names = FALSE)                         \n```\n:::\n\n\n\n1. The methods (and anything else you might be blocking on) need to come *before* the replication indicator.\n2. We need an `if` condition on the call to `generate()`: only generate new data once a new replication starts.\n3. Note that we have an analysis option now!\n\nNow we have two different methods and can compare them; let's look at Power ($\\delta \\ne 0$) this time:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres[, .(error = mean(p < 0.05)), .(sd2, delta, n1, equal_var)] %>%\n  .[delta == 1] %>%\n  ggplot(aes(n1, error, group=equal_var, color=equal_var)) +\n  geom_line() +\n  ylim(0, NA) +\n  facet_grid(~sd2, labeller = 'label_both') +\n  xlab('Sample size (group 1)') +\n  ylab('Power')\n```\n\n::: {.cell-output-display}\n![](simulation-design_files/figure-html/unnamed-chunk-9-1.png){width=816}\n:::\n:::\n\n\n\n# Additional remarks\n\nCertainly, there are some interesting statistical results here, but I'll let you ponder them on your own -- the point of this document is to illustrate how to organize a simulation study, and hopefully I have accomplished that or at least gotten you started down the road to better organization. There is certainly more that can be said, but I think these are the main principles to keep in mind.\n\n* For a more complicated project (like dissertation research!), you will likely want to set up a project; see [here](https://github.com/IowaBiostat/project-workflow) for more details on how you might set something like that up.\n* The above structure allows for specifying options from the command line; in this case, you might modify the block that species the options as follows:\n\n```r\nif (!interactive()) {\n  opt <- commandArgs(trailingOnly = TRUE)\n  cat(\"Running simulation with args:\", print(opt))\n} else {\n  opt <- list(\n    equal_var = c(TRUE, FALSE),\n    rep = 1:1000,\n    sd1 = 1,\n    sd2 = 1:3,\n    n1 = seq(2, 18, 2),\n    delta = c(0, 1))\n}\n```\n\n* Another approach to ensuring that competing methods are being compared using the same data is to pass the replication number to `generate()` and use it as a seed. An important advantage of this approach is that you can add a method later and don't have to rerun the entire simulation. A disadvantage is that if data generation is time-consuming, you don't want to repeat the data-generating process if it isn't necessary.\n* If you're interested in reading more on simulation design, I suggest the following articles:\n  * [Morris2019](https://doi.org/10.1002/sim.8086)\n  * [Strobl2024](https://doi.org/10.1002/bimj.202200104)\n  * [Chalmers2020](https://doi.org/10.20982/tqmp.16.4.p248)\n",
    "supporting": [
      "simulation-design_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}